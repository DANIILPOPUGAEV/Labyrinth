using Labyrinths.Enums;
using Labyrinths.Models;
namespace Labyrinths.Generators;

/// <summary>
/// Генератор лабиринта с использованием алгоритма DFS (Depth-First Search) со стеком.
/// Алгоритм создает "идеальные" лабиринты с одним уникальным путем между любыми двумя точками.
/// 
/// Принцип работы:
/// 1. Начинается со стартовой клетки (1,1) и помещает ее в стек
/// 2. Пока стек не пуст, извлекает текущую клетку
/// 3. Для каждой клетки проверяет соседей на расстоянии 2 шага
/// 4. Случайным образом выбирает непосещенного соседа
/// 5. Пробивает стену между текущей клеткой и выбранным соседом
/// 6. Помещает нового соседа в стек для дальнейшего исследования
/// </summary>
public class DfsGenerator : IGenerator
{
    private static readonly Random _rnd = new();
    private int width, height;
    private Maze? _maze;

    /// <summary>
    /// Генерирует лабиринт указанных размеров с использованием DFS алгоритма.
    /// Размеры автоматически приводятся к нечетным числам для создания правильной сетки стен.
    /// </summary>
    /// <param name="width">Ширина лабиринта (минимум 3, приводится к нечетному числу)</param>
    /// <param name="height">Высота лабиринта (минимум 3, приводится к нечетному числу)</param>
    /// <returns>Сгенерированный лабиринт с одним связным проходом</returns>
    public Maze Generate(int width, int height)
    {
        // Приведение размеров к нечетным числам для создания симметричной сетки
        // Операция (n | 1) гарантирует нечетность числа
        this.width = Math.Max(3, width | 1);
        this.height = Math.Max(3, height | 1);
        _maze = new Maze(this.width, this.height);

        VisitAll();
        return _maze;
    }

    /// <summary>
    /// Основной метод генерации, реализующий DFS с использованием стека.
    /// Алгоритм:
    /// 1. Инициализация начинается с точки (1,1) - первой проходимой клетки
    /// 2. Клетка помечается как пустая и добавляется в стек
    /// 3. Пока стек не пуст, извлекается текущая клетка
    /// 4. Для 4 направлений (вверх, вниз, влево, вправо) проверяются соседи на 2 шага
    /// 5. Непосещенные соседи (стены) добавляются в случайном порядке
    /// 6. Стена между текущей и новой клеткой пробивается
    /// 7. Новая клетка добавляется в стек для продолжения обхода
    /// </summary>
    private void VisitAll()
    {
        var stack = new Stack<Point>();

        // Начальная точка - всегда (1,1) для создания границ
        var start = new Point(1, 1);
        _maze!.Set(start, CellType.Empty);
        stack.Push(start);

        var dirs = new Point[] { new(2, 0), new(-2, 0), new(0, 2), new(0, -2) };

        // Направления движения с шагом 2 клетки
        // Каждое направление проверяет клетку через одну стену
        while (stack.Count > 0)
        {
            var cur = stack.Pop();
            // Поиск всех возможных соседей на расстоянии 2 клетки
            var neighbors = dirs.Select(d => new Point(cur.X + d.X, cur.Y + d.Y)) // Вычисление координат соседа
                                .Where(p => _maze.InBounds(p)) // // Проверка границ лабиринта
                                .Where(p => _maze.Get(p) == CellType.Wall) // Проверка, что сосед - стена
                                .OrderBy(_ => _rnd.Next()).ToArray();

            // Обработка каждого найденного соседа
            foreach (var n in neighbors)
            {
                // Вычисление средней точки между текущей и новой клеткой
                // Эта точка является стеной, которую нужно заменить на проход
                var mid = new Point((cur.X + n.X) / 2, (cur.Y + n.Y) / 2);
                _maze.Set(mid, CellType.Empty);
                _maze.Set(n, CellType.Empty);
                stack.Push(n);
            }
        }
    }
}
